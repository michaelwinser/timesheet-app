// Code generated by mcp-codegen from api-spec.yaml. DO NOT EDIT.

package mcp

import "encoding/json"

// ServerInfo contains MCP server metadata
type ServerInfo struct {
	Name         string
	Version      string
	Instructions string
}

// GetServerInfo returns the MCP server metadata
func GetServerInfo() ServerInfo {
	return ServerInfo{
		Name:         "timesheet",
		Version:      "1.0.0",
		Instructions: "You are an AI assistant helping manage a timesheet application.\n\nThe user tracks their time across different projects. Calendar events are synced from\nGoogle Calendar and need to be classified (assigned to projects or marked as skipped).\n\nIMPORTANT: Before using search_events, create_rule, or preview_rule tools, first read the\ntimesheet://docs/query-syntax resource to understand the query language.\n\nWhen helping the user:\n1. Read timesheet://docs/query-syntax to learn the search syntax\n2. List projects to understand available classification targets\n3. Search for pending events to see what needs attention\n4. Use preview_rule to test classification patterns\n5. Create rules or use bulk_classify to classify events\n",
	}
}

// Resource represents an MCP resource
type Resource struct {
	URI         string
	Name        string
	Description string
	MimeType    string
}

// GetResources returns all MCP resources
func GetResources() []Resource {
	return []Resource{
		{
			URI:         "timesheet://docs/query-syntax",
			Name:        "Query Syntax Reference",
			Description: "Complete reference for the Gmail-style query syntax used to search events and create classification rules",
			MimeType:    "text/markdown",
		},
	}
}

// Tool represents an MCP tool definition
type Tool struct {
	Name        string
	Description string
	InputSchema map[string]any
}

// GetTools returns all MCP tool definitions
func GetTools() []Tool {
	return []Tool{
		{
			Name:        "apply_rules",
			Description: "Run all enabled classification rules against pending events. This applies rules to unclassified events and creates time entries.",
			InputSchema: parseSchema(`{
				"properties": {
					"dry_run": {
						"default": false,
						"description": "If true, return what would be classified without making changes",
						"type": "boolean"
					},
					"end_date": {
						"type": "string"
					},
					"start_date": {
						"type": "string"
					}
				},
				"type": "object"
			}`),
		},
		{
			Name:        "bulk_classify",
			Description: "Classify multiple events matching a query to a project (or skip them). More efficient than classifying one by one.",
			InputSchema: parseSchema(`{
				"properties": {
					"project_id": {
						"description": "Project to assign matching events to. Omit to skip events.",
						"type": "string"
					},
					"query": {
						"description": "Gmail-style query to match events (e.g., \"domain:acme.com title:sync\")",
						"type": "string"
					},
					"skip": {
						"default": false,
						"description": "If true, mark matching events as skipped (did not attend)",
						"type": "boolean"
					}
				},
				"required": [
					"query"
				],
				"type": "object"
			}`),
		},
		{
			Name:        "classify_event",
			Description: "Classify a calendar event by assigning it to a project or skipping it.",
			InputSchema: parseSchema(`{
				"properties": {
					"event_id": {
						"description": "The calendar event ID to classify",
						"type": "string"
					},
					"project_id": {
						"description": "Project to assign this event to. Omit or null to skip the event.",
						"type": "string"
					},
					"skip": {
						"description": "Set to true to mark as \"did not attend\" (skipped)",
						"type": "boolean"
					}
				},
				"required": [
					"event_id"
				],
				"type": "object"
			}`),
		},
		{
			Name:        "create_rule",
			Description: "Create a new classification rule. The rule will automatically classify matching events to the specified project. Read timesheet://docs/query-syntax first to understand query syntax.",
			InputSchema: parseSchema(`{
				"properties": {
					"attended": {
						"description": "For attendance rules - false means \"did not attend\"",
						"type": "boolean"
					},
					"is_enabled": {
						"default": true,
						"type": "boolean"
					},
					"project_id": {
						"description": "Target project (required unless attended is set)",
						"type": "string"
					},
					"query": {
						"description": "Gmail-style query string",
						"type": "string"
					},
					"weight": {
						"default": 1,
						"type": "number"
					}
				},
				"required": [
					"query"
				],
				"type": "object"
			}`),
		},
		{
			Name:        "create_time_entry",
			Description: "Create a manual time entry for work not captured by calendar events.",
			InputSchema: parseSchema(`{
				"properties": {
					"date": {
						"type": "string"
					},
					"description": {
						"type": "string"
					},
					"hours": {
						"type": "number"
					},
					"project_id": {
						"type": "string"
					}
				},
				"required": [
					"date",
					"hours",
					"project_id"
				],
				"type": "object"
			}`),
		},
		{
			Name:        "explain_classification",
			Description: "Explain how an event was (or would be) classified. Shows all rules evaluated, which matched, score breakdown by project, and the final decision. Useful for debugging why an event was classified to a particular project.",
			InputSchema: parseSchema(`{
				"properties": {},
				"type": "object"
			}`),
		},
		{
			Name:        "get_time_summary",
			Description: "Get a summary of time entries grouped by project or date. Useful for analyzing time spent.",
			InputSchema: parseSchema(`{
				"properties": {
					"end_date": {
						"description": "End date (YYYY-MM-DD). Defaults to today.",
						"type": "string"
					},
					"group_by": {
						"default": "project",
						"description": "How to group: 'project' or 'date'",
						"enum": [
							"project",
							"date"
						],
						"type": "string"
					},
					"project_id": {
						"description": "Filter by project",
						"type": "string"
					},
					"start_date": {
						"description": "Start date (YYYY-MM-DD). Defaults to 7 days ago.",
						"type": "string"
					}
				},
				"type": "object"
			}`),
		},
		{
			Name:        "list_pending_events",
			Description: "List calendar events that need classification (assignment to a project or skip).",
			InputSchema: parseSchema(`{
				"properties": {
					"classification_status": {
						"enum": [
							"pending",
							"classified",
							"skipped"
						],
						"type": "string"
					},
					"connection_id": {
						"type": "string"
					},
					"end_date": {
						"description": "End date (YYYY-MM-DD). Defaults to today.",
						"type": "string"
					},
					"limit": {
						"default": 20,
						"description": "Maximum events to return",
						"type": "integer"
					},
					"start_date": {
						"description": "Start date (YYYY-MM-DD). Defaults to 30 days ago.",
						"type": "string"
					}
				},
				"type": "object"
			}`),
		},
		{
			Name:        "list_projects",
			Description: "List all projects. Use this first to understand available options for classification.",
			InputSchema: parseSchema(`{
				"properties": {
					"include_archived": {
						"default": false,
						"description": "Include archived/inactive projects",
						"type": "boolean"
					}
				},
				"type": "object"
			}`),
		},
		{
			Name:        "list_rules",
			Description: "List all classification rules. Rules automatically assign events to projects based on query patterns.",
			InputSchema: parseSchema(`{
				"properties": {
					"include_disabled": {
						"default": false,
						"description": "Include disabled rules",
						"type": "boolean"
					}
				},
				"type": "object"
			}`),
		},
		{
			Name:        "preview_rule",
			Description: "Test a query against events to see what would match before creating a rule. Always use this before create_rule to verify the query works as expected.",
			InputSchema: parseSchema(`{
				"properties": {
					"end_date": {
						"description": "End of date range to search (YYYY-MM-DD)",
						"type": "string"
					},
					"project_id": {
						"description": "Target project (for conflict detection)",
						"type": "string"
					},
					"query": {
						"description": "Query to preview",
						"type": "string"
					},
					"start_date": {
						"description": "Start of date range to search (YYYY-MM-DD)",
						"type": "string"
					}
				},
				"required": [
					"query"
				],
				"type": "object"
			}`),
		},
		{
			Name:        "search_events",
			Description: "Search calendar events using query syntax. Read the timesheet://docs/query-syntax resource first to understand the query language. Use this to find events by status, project, attendees, title, etc.",
			InputSchema: parseSchema(`{
				"properties": {
					"classification_status": {
						"enum": [
							"pending",
							"classified",
							"skipped"
						],
						"type": "string"
					},
					"connection_id": {
						"type": "string"
					},
					"end_date": {
						"description": "End date (YYYY-MM-DD). Defaults to today.",
						"type": "string"
					},
					"limit": {
						"default": 50,
						"description": "Maximum events to return (default 50)",
						"type": "integer"
					},
					"query": {
						"description": "Query string using the search syntax (e.g., 'status:pending', 'domain:acme.com', 'title:standup'). See timesheet://docs/query-syntax resource.",
						"type": "string"
					},
					"start_date": {
						"description": "Start date (YYYY-MM-DD). Defaults to 30 days ago.",
						"type": "string"
					}
				},
				"type": "object"
			}`),
		},
	}
}

// parseSchema parses a JSON schema string into a map
func parseSchema(s string) map[string]any {
	var result map[string]any
	if err := json.Unmarshal([]byte(s), &result); err != nil {
		panic("invalid schema: " + err.Error())
	}
	return result
}

// ToolNames returns a list of all tool names
func ToolNames() []string {
	tools := GetTools()
	names := make([]string, len(tools))
	for i, t := range tools {
		names[i] = t.Name
	}
	return names
}
